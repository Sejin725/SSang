ch02 목차

! 대소문자 비교 방법
(ch>='A') && (ch<='Z') ? "대문자임" : "소문자임";


kr.s01.field - 객체 클래스의 내용 및 변수 설정관련

kr.s02.Instance - 클래스의 기본구조(생성자, 메서드, 변수 등의 내용)

kr.s03.method - 클래스의 메소드(함수) 이용관련한 내용
	Variable Arguments - 인자전달방식 MethodArgMain01.java


kr.s04.p1~p2 - 패키지와 임포트의 사용예시

kr.s05.overloading - 메소드의 오버로딩(재사용성)

kr.s06.capsule - 객체 또는 변수의 보안 (캡슐화)
	객체의 변수의 값을 마음대로 변경하는걸 막기위해 private 를 선언하여 막아둠

kr.s07.constructor - 생성자 (오버로딩)
	생성자를 만들때 초기화를 하지않고 실행문을 먼저 명시할시 오류가 발생함

kr.s08.statictest - Static(스태틱) "객체와는 상관없이" 클래스 전체에 고정된 값
	따라서 해당 메모리를 공유 하므로 해당 클래스의 모든 객체에서 동일한 메모리값을 사용함
	Static메서드 또한 "객체생성과 무관하게" 메서드를 직접 호출을 할 수 있다.
	static 변수는 기본적으로 public 으로 명시가 되어 사용한다. (멤버변수는 default)


kr.s09.thistest - this 연산자에 대한 설명 -> 
	메서드 생성시 인자값의 변수명과 동일할떄 자기자신을 호출하기 위함

kr.s11.array - 객체를 배열에 넣어서 사용하는 방법
	예시) Car[] c = new Car[]; 선언이후 배열내에 각 인덱스마다 생성자를 이용하여 생성해야 객체마다 주소가 할당됨. (기본값=null)
		 c[0] = new Car(); (0번 인덱스의 객체에 주소할당)

kr.s12,14.extention - 상속, 접근제한에 따른 호출 방법에 관한 내용

kr.s15.overriding - 메서드 오버라이딩(상속관계 메서드 덮어쓰기) 관한 내용

kr.s16.supertest - 동일한 메서드, 변수를 호출하였을때, 부모의 것을 참조하기 위해 사용되는 예약어

kr.s17.poly - 객체의 형변환
				자식클래스 -> 부모클래스 (업캐스팅)
				부모클래스 -> 자식클래스 (다운캐스팅)
			  Instanceof
			    왼쪽에 표시한 객체가 연산자 오른쪽에 명시한 자료형을 사용할 수 있는지 여부를 체크함
			    
kr.s19.lang - Object클래스에 내장된 메서드 알아보기
		- 	//클래스 정보 반환 		- getClass()
			//클래스명 반환 		- getClass().getName()
			//해시코드 (10진수)반환 	- hashCode()
			//해시코드 (16진수)반환 	- Integer.toHexString(om.hashCode())
			//참조값 반환 			- toString()
			  String클래스의 메서드
			  StringBuffer의 메서드 - String은 내용 변환시 객체를 계속해서 생성하지만 Buffer는 그렇지 않다.
			  Math클래스의 메서드
			  Wrapper클래스 -> 자료형들의 각종 메서드를 사용할수있는 기본형
			  
kr.s20.util - 유틸리티 클래스 안에 내장된 쓸만한 클래스들
			Calendar			- 년, 월, 일, 시, 분, 초를 필요한것만 뽑아낼때 이용
			Date				- 년, 월, 일, 시, 분, 초를 여러가지 방법으로 한 번에 저장, 추출할 수 있음
			StringTokenizer		- 구분자를 지정하여 문자열을 잘라내줌 [ String.split()보다 강력함 ]
			
kr.s21.abs	- Abstract(추상적 클래스)
	클래스를 생성할떄 쓰는 옵션, 껍데기용 설계도면 클래스를 만든다고 생각하면 된다.
	추상 클래스를 만들고 나서부터는 자식클래스로 뽑아내서 더 구현화 하면 된다.

final -> 상수 : 변하지않는 고정 값
	메서드에 final을 지정하면 자식클래스에서 메서드 오버라이딩을 할 수 없음
	클래스에 final을 명시하면 상속 불가능
	
enum -> 열거형 상수 : 클래스와는 상관없는 변하지않는 고정 값


kr.s24.interfacetest (공통된 부분들만 추려내어 일반화 할 수 있도록 만들기위해 사용하는 것)
	인터페이스 내부에 변수를 생성해놓을경우, public static final이 생략이된다. (모든 변수는 상수)
	인터페이스 내부에 메서드를 생성해놓을경우, public abstract 이 생략되어 있음  (모든 메서드는 추상메서드가 됨)
	해당 인터페이스를 클래스에 상속받아 구현할경우, extends가 아닌 Implements로 구현해야한다.
	1. 인터페이스는 다중상속을 주는 효과를 부여한다. (하나의 클래스는 여러 부모 클래스를 둘수 없기에 인터페이스로 구현함)
	2. 자료형으로 사용가능함
	3. 인터페이스간의 다중 상속은 가능하다.
	4. 일반화를 이용한 사용법

	