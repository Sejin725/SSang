
정보처리산업기사 요약 (깃허브 테스트)

1. 운영체제의 개요
 - 컴퓨터 시스템의 자원들을 효율적으로 관리한다.
 - 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공한다.
 
2.운영체제의 목적
 - 처리능력 향상
 - 반환시간 단축
 - 사용가능도 향상
 - 신뢰도 향상

3. 운영체제의 기능
 - 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리한다.
 - 자원의 스케줄링 기능을 제공한다.
 - 사용자와 시스템 간의 인터페이스를 제공한다.
 - 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.
 
4. 운영체제 운용 기법
 - 실시간 처리 시스템 : 처리할 데이터가 생겨날 떄 마다 바로 처리하는 방식
 - 분산 처리 시스템 : 지역적으로 분산된 여러대의 컴퓨터를 연결하여 작업을 분담하여 처리하는 방식
 - 다중 프로그래밍 시스템 : 한 개의 CPU로 여러 개의 프로그램을 동시에 처리하는 방식
 - 다중 처리 시스템 : 하나의 컴퓨터에 여러 개의 CPU를 설치하여 프로그램을 처리하는 방식
 - 임베디드 시스템 : 마이크로프로세서에 특정 기능을 수행하는 응용 프로그램을 탑재하여 컴퓨터의 기능을 수행하는 방식
 
5. 운영체제 운영 기법의 발달 과정
 - 1세대 : 일괄 처리 시스템
 - 2세대 : 다중 처리 시스템, 시분할 시스템, 실시간 처리 시스템
 - 3세대 : 다중모드
 - 4세대 : 분산 처리 시스템
 
6. 프로세스의 정의
 - PCB를 가진 프로그램
 - 주기억장치에 저장된 프로그램
 - 프로세서가 할당되는 실체
 - 프로시저가 활동중인 것
 - 비동기적 행위를 일으키는 주체
 - 지정된 결과를 얻기 위한 일련의 계통적 동작
 - 목적 또는 결과에 따라 발생되는 사건들의 과정
 
7. 프로세스 상태 전이
 - 제출(Submit) : 사용자가 작업을 시스템에 제출한 상태
 - 접수(Hold) : 제출된 작업이 디스크의 할당 위치에 저장된 상태
 - 준비(Ready) : 프로세서를 할당받기 위해 기다리고 있는 상태
 - 실행(Run) : 프로세서를 할당받아 실행되는 상태
 - 대기(Wait),보류,블록(Block) : 입출력 처리가 완료될 때 까지 대기하고 있는 상태
 - 종료(Terminated, Exit) : 실행이 끝나고 프로세스 할당이 해제된 상태
 
8. 스케줄링 - FCFS(FIFO)								==== 스케줄링 그림 확인 필요 ===
 - 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법		==========================
													==========================
9. 스케줄링 - SJF 										==== 스케줄링 그림 확인 필요 ===
 - 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법		==========================
 
10. 스케줄링 - RR(Round Robin)
 - 시분할 시스템을 위해 고안된 방식이다.
 - FCFS 알고리즘을 선점 형태로 변형한 기법이다.
 - 할당되는 시가닝 클 경우 FCFS 기법과 같아진다.

11. 교착상태 발생의 필요 충분 조건
 - 상호 배제(Mutual Exclusion) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
 - 점유와 대기(Hold and Wait) : 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로
							 점유하기 위해 대기하는 프로세스가 있어야 함
 - 비선점(Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺴앗을 수 없어야 함
 - 환형 대기(Circular Wait) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어야함
 
12. 기억장치의 배치 전략
 - 최초적합(First Fit) : 첫 번째 분할 영역에 배치
 - 최적적합(Best Fit) : 단편화를 가장 작게 남기는 분할 영역에 배치
 - 최악적합(Worst Fit) : 단편화를 가장 많이 남기는 분할 영역에 배치
 
13. 가상기억장치 - 페이징 기법
 - 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 적재시켜 실행하는 기법이다.
 - 프로그램을 일정한 크기로 나눈 단위를 페이지라고 한다.
 - 내부 단편화가 발생할 수 있다.
 
14. 가상기억장치 - 세그먼테이션 기법
 - 다양한 크기의 논리적인 단위로 나눈 후 적재시켜 실행시키는 기법이다.
 - 프로그램을 논리적인 크기로 나눈 단위를 세그먼트라고 한다.
 - 외부단편화가 발생할 수 있다.
 
15. 주요 페이지 교체 알고리즘
 - FIFO(큐) : 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
 - LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
 - NUR : 최근에 사용하지 않은 페이지를 교체하는 기법, 참조 비트와 변형 비트가 사용됨
 
16. 주요 디스크 스케줄링											===================
 - FCFS : 가장 먼저 들어온 트랙에 대한 요청을 먼저 서비스하는 기법			=== 그림 확인 필요 ===
 - SSTF : 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스하는 기법 	===================

17. 직접 파일(Direct File)
 - 레코드를 임의의 물리적 저장공간에 기록하는 것이다.
 - 해싱 함수를 이용하여 물리적 상대주소를 계산한다.
 
18. 2단계 디렉터리
 - 중앙에 마스터 파일 디렉터리가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉터리가 있는 2계층 구조이다.
 - 마스터 파일 디렉터리는 사용자 파일 디렉터리를 관리한다.
 - 사용자 파일 디렉터리는 사용자별 파일을 관리한다.

19. 권한(자격)리스트
 - 영역을 중심으로 권한 리스트를 구성한 것이다.
 - 각 영역에 대한 권한 리스트는 객체와 그 객체에 허용된 조작 리스트로 구성된다.
 
20. UNIX의 특징
 - 대부분 C언어로 작성되어 있어 이식성이 높다.
 - 장치와 프로세스 간의 호환성이 높다
 - 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.
 - 트리 구조의 파일 시스템을 갖는다.
 
21. UNIX - 커널(Kernel)의 기능
 - 프로세스(CPU 스케줄링)관리
 - 기억장치 관리
 - 파일 시스템 관리 
 - 입 출력 관리 
 
22. UNIX - 쉘(Shell)
 - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
 - 시스템과 사용자 간의 인터페이스를 담당한다.
 
23. UNIX의 주요 명령어
 - cat : 파일 내용을 화면에 표시함
 - chmod : 파일의 보호 모드를 설정하여 파일의 사용허가를 지정함
 - chown : 소유자를 변경함
 - exec : 새로운 프로세스를 수행함
 - fork : 새로운 프로세스를 생성함
 - ls : 현재 디렉터리 내의 파일 목록을 확인함
 
24. 비동기식 전송
 - 시작 비트와 정지 비트를 붙여서 전송하는 방식이다.
 - 문자와 문자 사이의 휴지 시간이 불규칙하다.
 
25. 해밍 코드
 - 수신 측에서 오류가 발생한 비트를 검출한 후 직접 수정하는 방식이다.
 - 1비트의 오류만 수정이 가능하다.
 
26. 통신 프로토콜
 - 서로 다른 기기들 간의 데이터 교환을 정확하고 원활하게 수행할 수 있도록 표준화한 통신 규약이다.
 
27. OSI 7계층
 - 물리계층 -> 데이터링크계층 -> 네트워크계층 -> 전송계층 -> 세션계층 -> 표현계층 -> 응용계층
 
28. OSI 7계층의 주요계층
 - 데이터링크계층 : 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당함
 - 네트워크계층 : 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함
 - 전송계층 : 종단 시스템 간에 투명한 데이터 전송을 가능하게 함
 
29. X.25의 계층 구조
 X.25란? : ITU-T에서 제정한 국제 표준 프로토콜로, 우수한 호환성을 가집니다.
 - 물리계층
 - 프레임계층
 - 패킷계층
 
30. TCP/IP 계층별 주요 프로토콜
 - 응용계층 : Telnet, FTP, SMTP, SNMP, E-Mail 등
 - 전송계층 : TCP, UDP 등
 - 인터넷 계층 : IP, ICMP, IGMP, ARP, RARP 등
 - 네트워크 액세스 계층 : Ethernet, IEEE 802, HDLC, X.25, RS-232C 등

31. 경로제어(라우팅)프로토콜
 - 종류 : RIP, OSPF, EGP, BGP, EIGRP 등
 - 거리 벡터 방식 : RIP, EIGRP, BGP 등
 - 링크 상태 방식 : OSPF
 
32. 패킷교환방식
 - 메세지를 일정한 길이의 패킷으로 잘라서 전송하는 방식이다.
 - 음성 전송보다 데이터 전송에 더 적합하다.
 - 장애가 발생하여도 다른 정상적인 경로를 선택하여 우회할 수 있다.
 - 대량의 데이터 전송 시 전송지연이 많아진다.

33. 고속이더넷
 - 100BASE T라고도 불리는 이더넷의 고속 버전이다.
 - CSMA/CD를 사용하며, UTP케이블을 이용해 100Mbps의 속도로 전송한다.

34. IPv6주소
 - 16비트씩 8부분, 총 128비트로 구성되어 있다.
 - 각 부분을 16진수로 표현하고, 콜론(:)으로 구분한다.
 - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.
 - 주소의 확장성, 융통성, 연동성이 뛰어나다.
 
35. 소프트웨어 공학의 기본 원칙
 - 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
 - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
 - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.
 
36. 폭포수 모형
 - 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 다음 단계를 진행하는 개발 방법론이다.
 - 보헴이 제시한 고전적 생명 주기 모형이다.
 - 요구사항을 반영하기 어렵다.
 
37. 나선형 모형
 - 나선을 따라 돌듯이 점진적으로 완벽한 최종 소프트웨어를 개발하는 것이다.
 - "계획수립 -> 위험분석 -> 개발 및 검증 -> 고객평가" 과정이 반복적으로 수행한다.
 
38. 애자일 개발 4가지 핵심가치
 - 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
 - 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
 - 계약 협상보다는 고객과 협업에 더 가치를 둔다.
 - 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.

39. XP(Extreme Programming)의 핵심가치
 XP란? : 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
 - 의사소통(Communication)
 - 단순성(Simplicity)
 - 용기(Courage)
 - 존중(Respect)
 - 피드백(Feedback)
 
40. 자료 흐름도의 구성요소
	===================
	=== 그림 확인 필요 ===
	===================

41. 자료 사전의 표기기호
 - = : 정의
 - + : 연결
 - () : 생략
 - [|] : 선택
 - {} : 반복
 - ** : 설명

42. UML
 - 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
 - 구성 요소 : 사물(Things), 관계(Relationships), 다이어그램(Diagram)
 
43. UML의 주요 관계
 - 일반화(Generalization)관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
 
44. 소프트웨어 아키텍처 뷰의 종류
 - 유스케이스(Use Case) 뷰
 - 논리적(Logical) 뷰
 - 구현(Implementation) 뷰
 - 프로세스(Process) 뷰
 - 배포(Deployment) 뷰
 
45. 파이프-필터 패턴
 - 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.
 - 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다.
 
46. 메소드
 - 객체가 메시지를 받아 실행해야 할 때, 객체의 구체적인 연산을 정의한 것이다.
 
47. 클래스
 - 공통된 속성과 연산을 갖는 객체의 집합이다.
 - 클래스에 속한 각각의 객체를 인스턴스라 한다.
 
48. 추상클래스 (Abstract)
 - 구체 클래스에서 구현하려는 기능들의 공통점만을 모아 추상화한 클래스이다.
 - 인스턴스 생성이 불가능하다.
 
49. 캡슐화(Encapsulation)
 - 데이터와 데이터를 처리하는 함수를 하나로 묶는것을 의미한다.
 - 외부 모듈의 변경으로 인한 파급 효과가 적다.
 - 재사용이 용이하다.
 
50. 상속(Inherritanca)
 - 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.
 
51. 럼바우의 분석 기법
 - 객체(Object)모델링 : 정보 모델링이라고도 하며, 속성과 연산 식별 및 객체들 간의 관계를 규정하여
					 객체 다이어그램으로 표시하는 것.
 - 동적(Dynamic)모델링 : 상태 다이어그램을 이용하여 객체들 간의 동적인 행위를 표현하는 모델링
 - 기능(Functional)모델링 : 자료 흐름도를 이용하여 프로세스들 간의 처리 과정을 표현한 모델링

52. 생성패턴-빌더(Builder)
 - 인스턴스를 건축 하듯이 조합하여 객체를 생성한다.
 - 객체의 생성 과정과 표현 방법을 분리하고 있다.

53. 생성 패턴-프로토타입(Prototype)
 - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
 - 비용이 큰 경우 주로 이용한다.
 
54. 생성 패턴-싱글톤(Singleton)
 - 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
 - 불필요한 메모리 낭비를 최소화할 수 있다.
 
55. 구조 패턴-데코레이터(Decorator)
 - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다.
 - 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다.
 
56. 화이트박스 테스트
 - 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법이다.
 - 원시 코드의 모든 문장을 한 번 이상 실행함으로써 수행된다.
 
57. 화이트박스 테스트-루프 검사
 - 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법이다.
 - 반복 구조 : 단순 루프, 중첩 루프, 연결 루프, 비구조적 루프
 
58. 화이트박스 테스트의 종류
 - 기초 경로 검사
 - 제어 구조 검사 : 조건검사, 루프검사, 데이터흐름검사
	
59. 블랙박스 테스트 종류
 - 동치 분할 검사
 - 경계값 분석
 - 원인-효과 그래프 검사
 - 오류 예측 검사
 - 비교 검사
 
60. 소프트웨어 테스트 순서
 - 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트

61. 단위 테스트
 - 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것이다.
 - 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행한다.
 
62. 통합 테스트
 - 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법이다.
 - 종류 : 하향식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트
 
63. 사용자 인터페이스의 특징
 - 사용자의 편리성과 가독성을 높여준다.
 - 작업 시간을 단축시킨다.
 - 업무에 대한 이해도를 높여준다.
 - 사용자 중심으로 설계되어 있다.

64. 사용자 인터페이스의 구분
 - CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스
 - GUI(Graphical User Interface) : 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 
 								   그래픽 환경의 인터페이스
 - NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
 
65. 형상 관리
 - 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
 - 관리 항목 : 소스 코드, 프로젝트 계획, 분석서, 설계서, 지침서, 프로그램, 테스트 케이스 등
 
66. 빌드 자동화 도구
 - 빌드를 포함하여 테스트 및 배포를 자동화하는 도구이다.
 - 종류 : Ant, Make, Maven, Gradle, Jankins 등

67. C/C++의 데이터 타입과 크기
 - 문자 : 				char 1Byte
 - 부호없는 문자형 : 	unsigned char 1Byte
 - 정수 : 				short 2Byte				| int 4Byte
 - 부호없는 정수형 : 	unsigned short 2Byte	| unsigned int 4Byte
 - 실수 : 				float 4Byte				| double 8Byte 

68. 변수명 작성 규칙
 - 첫 글자로 숫자는 올 수 없다.
 - 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없다.
 - 예약어를 변수명으로 사용할 수 없다.
 
69. 상수의 생성
 - C언어에서 상수를 만들 때는 const 또는 #define 예약어를 사용한다.
 
70. 외부 변수
 - 변수나 함수를 참조(reference)하기 위한 변수이다.
 - 함수가 종료된 뒤에도 값이 소멸되지 않는다.
 
71. 산술 연산자
 - (%) 나머지 : 정수만 연산할 수 있으며, 실수를 사용하면 오류가 발생함
 - (++) 증가 : 변수 앞에 증감 연산자가 오는 형태로 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용함
 - (--) 감소 : 변수 뒤에 증감 연산자가 오는 형태로 먼저 변수를 연산에 사용한 후 변수의 값을 증감시킴
 
72. 관계 연산자
 - (==) : 같다
 - (!=) : 같지 않다
 - (>) : (왼쪽이)크다
 - (>=) : (왼쪽이)크거나 같다
 - (<) : (왼쪽이)작다
 - (<=) : (왼쪽이)작거나 같다

73. 비트 연산자
 - &(and) : 모든 비트가 1일 때만 1
 - ^(xor) : 모든 비트가 같으면 0, 하나라도 다르면 1
 - |(or)  : 모든 비트 중 한 비트라도 1 이면 1
 - ~(not) : 각 비트의 부정, 0이면 1, 1이면 0
 - <<(왼쪽 시프트)  : 비트를 왼쪽으로 이동
 - >>(오른쪽 시프트): 비트를 오른쪽으로 이동
 
74. 논리 연산자
 - !  (not) : 부정
 - && (and) : 모두 참이면 참
 - || (or)  : 하나라도 참이면 참
 
75. 조건 연산자
 - 조건에 따라 서로 다른 수식을 수행한다.
 
76. 연산자 우선순위
 - 단항 연산자 > 산술 연산자> 시프트 연산자 > 관계 연산자 > 비트 연산자 > 논리 연산자 > 조건 연산자 >
 	대입 연산자 > 순서 연산자
 	
77. scanf() 함수
 - 키보드로 입력받아 변수에 저장하는 함수이다.
  ex) scanf("%d, %f", &i, &j);	정수를 입력받아 i에 저장, 실수를 입력받아 j에 저장
  
78. 주요 서식 문자열
 - %d : 정수형 10진수를 입출력 하기 위해 지정함
 - %o : 정수형 8진수를 입출력 하기 위해 지정함
 - %x : 정수형 16진수를 입출력 하기 위해 지정함
 - %c : 문자를 입출력 하기 위해 지정함
 - %s : 문자열을 입출력 하기 위해 지정함
 - %f : 소수점을 포함하는 실수를 입출력 하기 위해 지정함

79. printf()함수
 - 인수로 주어진 값을 화면에 출력하는 함수이다.
  ex) printf("%d, %c", a,b);	a값을 정수로 출력, b값을 문자로 출력

80. 주요 제어문자
 - \n : 다음 줄 앞으로 이동함
 - \b : 왼쪽으로 한 칸 이동함
 - \t : 일정 간격 띄움
 - \r : 현재 줄의 처음으로 이동함
 - \0 : 널 문자를 출력함
 - \a : 스피커로 벨 소리를 출력함
 - \\ : 역 슬래시를 출력함
 - \f : 한 페이지를 넘김

81. Java에서의 표준 출력
 - printf()
 - print()
 - println()
 
82. 기타 표준 입출력 함수
 - getchar() : 키보드로 한 문자를 입력받아 변수에 저장하는 함수
 - gets() : 키보드로 문자열을 입력받아 변수에 저장하는 함수로, [Enter]를 누르기 전까지를 하나의 문자열로 인식
 - putchar() : 인수로 주어진 한 문자를 화면에 출력하는 함수
 - puts() : 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동하는 함수
 
83. 파일 입력 함수
 - fscnaf() : 파일 포인터 변수가 가리키는 위치에서 데이터를 가져와 지정한 자료형으로 변수에 저장하는 함수
 - fgetc() : 파일로부터 한 문자를 입력받아 변수에 저장하는 함수
 - fgets() : 파일로부터 문자열을 입력받아 변수에 저장하는 함수

84. if문
85. switch문
86. for문
87. while문
88. do ~ while문

89. 1차원 배열
 - 변수들을 일직선상의 개념으로 조합한 배열이다.
  ex) char a[3] = {'A', 'B', 'C'}; = 3개의 요소를 갖는 문자형 배열 a를 선언함
  
90. 2차원 배열
 - 변수들을 평면, 즉 행과 열로 조합한 배열이다.
  ex) int b[2][3] = {{11, 22, 33}, {44, 55, 66}}; = 2행 3열의 정수형 배열b 선언

91. 배열 형태의 문자열 변수
 - C언어에서는 큰따옴표("")로 묶인 글자는 글자 수에 관계없이 문자열로 처리된다.
 - 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자('\0)가 문자열 끝에 자동으로 삽입된다.
  ex) char a[5] = "love"; => 맨 끝 a[4] 자리에 널 문자가 자동 삽입됨

92. 포인터와 포인터 변수 - ########
 - 포인터 변수를 선언할 떄는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 '*' 를 붙인다. (ex : int *a;)
 - 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙인다.
 - 실행문에서 포인터 변수에 간접 연산자 *를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다.

93. 포인터와 배열
 - 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있다.
 - 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를
   지정하는 것과 같다.
   
94. 사용자 정의 함수
 - 사용자가 필요한 기능을 취향대로 만들어 사용할 수 있는 함수이다.

95. Python의 기본 문법
 - if나 for와 같이 코드 블록을 포함하는 명령문을 작성할때 코드 블록은 콜론(:)과 여백으로 구분한다.
 - 문자열에 따옴표가 포함되는 경우 다른 따옴표를 이용하여 문자열을 묶어줘야 한다.
  ex) 'She said "I like it"'

96. Python의 input()함수
 - 키보드로 입력받아 변수에 저장하는 함수이다.
 - 입력되는 값은 문자열로 취급되어 저장된다.
  ex) a = input('입력하세요')
 
97. Python의 print()함수
 - 인수로 주어진 값을 화면에 출력하는 함수이다.
 - 옵션으로 (sep, end, format, Escape) 가 있다.
  ex) print(82, 24, sep = '_', end =',')  출력--> 82_24,
 
98. Range
 - 연속된 숫자를 생성하는 것으로, 리스트, 반복문 등에서 많이 사용된다.
  ex) b = list(range(4, 9))  =>  4에서 8까지 연속된 숫자를 리스트 b로 저장한다.
  ex) c = list(range(1, 15, 3))  =>  1에서 14까지 3씩 증가하는 숫자들을 리스트 c로 저장한다.
  
99. 슬라이스
 - 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(slicing) 반환하는 기능이다.
  ex) a = ['a','b','c','d','e']일때
  	  a[1:3] 	-> ['b','c']
  	  a[0:5:2] 	-> ['a','c','e']
  	  a[3:] 	-> ['d','e']
  	  a[:3] 	-> ['a','b','c']

100. Python의 for문
 - range를 이용하는 방식
  ex) for i in range(1, 11);
		sum = sum + i

101. Python의 클래스
 - 클래스를 사용하려면 클래스 이름을 정하고 객체 생성을 위한 속성과 메소드(함수)를 정의한 후,
   객체를 선언하면 된다.
 - 메서드를 생성할때 인자값에 self를 넣으면, 메서드 호출시에 자동으로 자기자신 객체를 변수로 집어넣음
   
102. HTML-프레임의 주요 태그
 <frameset> 태그	 (HTML5부터는 사용안함)
  - 화면을 분할한다.
  - <frameset>...</frameset> 태그 사이에는 분할할 프레임의 개수만큼 <frame> 태그를 사용한다.
  
 <frame> 태그	 	 (HTML5부터는 사용안함)
  - 분할된 각각의 프레임에 표시할 HTML 문서를 지정한다.
  - <frameset>으로 분할된 영역에 <frame> 태그가 적용되는 순서는 다음과 같다.
   * 화면이 가로로 분할된 경우 : 위쪽 -> 아래쪽
   * 화면이 세로로 분할된 경우 : 왼쪽 -> 오른쪽
  - 분할된 프레임의 개수는 <frameset>의 rows 또는 cols속성으로 알 수 있다.

103. TML - 테이블의 주요 태그
 - <table> : 테이블에 관한 세부사항을 설정함
 - <thead> : 테이블의 머리글 부분을 정의함
 - <tbody> : 테이블의 본문 부분을 정의함
 - <tfoot> : 테이블의 바닥글 부분을 정의함
 - <tr> : 행을 만듦
 - <td> : 셀을 만듦
 - <th> : 셀을 만들면서 제목 스타일을 적용함
 
104. HTML - <style> 태그
 - 서식을 지정하는 태그로, <head> 부분에 지정하면 테이블 전체에 공통으로 적용된다.
 
105. HTML <form> 태그
 - 사용자로부터 정보를 입력받는 틀을 정의한다.
 - 관련속성
  	* method : 데이터 전송 방식을 지정함
   		# get : 입력받은 데이터를 URL에 첨부하여 전송함
   		# post : 입력받은 데이터를 메세지 형식으로 전송함
 	* action : 데이터를 전송할 URL을 지정함

106. JavaScript - document.write()
 - 가장 일반적인 출력 메소드로, 인수로 출력할 데이터를 입력하면 화면에 데이터가 출력된다.
 	ex) document.write("Sinagong"); -> 화면에 Sinagong이 출력됨
 
107. JavaScript - 대화상자
 - 알림 대화상자 : alert(내용);		-> 대화상자 본문에'내용'이 표시되고, 아래쪽에 <확인> 단추가 표시
 - 확인 대화상자 : confirm(내용);	-> 대화상자 본문에'내용'이 표시되고, 아래쪽에 <확인> 과 <취소> 단추가 표시
 - 입력 대화상자 : prompt(내용, 기본값);
   -> 대화상자 본문에'내용'이 표시되고, '내용' 아래에 '기본값'이 입력된 텍스트 상자가 표시된다.
   -> 대화상자 아래쪽에 <확인>과 <취소> 단추가 표시된다.
   
108. JavaScript - 배열의 주요 메소드
 - pop() 	: 배열의 마지막 요소를 제거함
 - push() 	: 배열의 마지막에 요소를 추가함
 - join() 	: 배열의 모든 요소를 하나의 문자열로 변환함
 - shift() 	: 배열의 첫 번째 요소를 제거함
 - splice() : 배열에서 지정한 범위의 요소를 제거한 후 제거된 위치에 지정한 값을 저장함
 
109. 객체지향 프로그래밍 언어의 종류
 - JAVA	: 분산 네트워크 환경에 적용할 수 있다. && 캡슐화가 가능하고 재사용성이 높다.
 - C++  : C 언어에 객체지향 개념을 적용한 언어
 - Smalltalk : 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어

110. 객체지향 프로그래밍 언어의 구성 요소
 - 객체(Object) : 데이터(속성)와 이를 처리하기 위한 연산(메소드)을 결합시킨 실체
 - 클래스(Class) : 두 개 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현하는 요소
 
111. 객체지향 프로그래밍 언어의 주요 특징
 - 캡슐화(Encapsulation) : 데이터(속성)와 함수를 하나로 묶는 것
 - 상속성(Inheritance) : 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
 
112. 스크립트 언어의 종류
 - 자바스크립트 : 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어
 - PHP : Linux, Unix, Windows 운영체제에서 사용 가능한 서버용 스크립트 언어
 - 파이썬(Python) : 귀도 반 로섬이 발표한 대화형 인터프리터 언어
 - 쉘 스크립트 : 쉘에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
 - Basic : 절차지향 기능을 지원하는 대화형 인터프리터 언어
 
113. 쉘 스크립트에서 사용되는 제어문
 - 선택형 : if, case
 - 반복형 : for, while, until
 
114. JavaScript 프레임워크의 종류
 - jQuery : 웹 브라우저 간의 호환성 문제를 해결하고 명령어를 단순화한 프레임워크
 - React : 메타(META)에서 개발한 프레임워크
 - Angular : 구글(Google)에서 개발한 프레임워크
 - Node.js : 인터넷 브라우저 외에도 Javascript가 동작하도록 함
 - Ember : 웹 애플리케이션을 위한 다양한 기능 제공
 
115. C언어의 대표적인 표준 라이브러리
 - math.h : 수학 함수들을 제공한다. && 주요함수 : sqrt, pow, abs 등
 - stdlib.h : 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공한다. 
 			  && 주요함수 : atoi, atof, srand, rand, malloc, free 등
 			  
116. try ~ catch 문
 - C++, C#, Java, JavaScript 등의 언어에서 예외 처리기능을 수행하는 명령문이다.
 - 일반적으로 예외가 발생한 경우에는 'try문 -> 해당예외 catch문 -> finally문'순으로 진행한다.
 - finally 블록은 예외의 발생과 관계없이 무조건 수행되는데, C++에서는 사용할 수 없다.
 
117. 프레임워크의 특성
 - 모듈화(Modualrity)
 		캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써
 		소프트웨어의 품질을 향상시키고 유지보수를 용이하게 함
 - 재사용성(Reusability) 
 		재사용 가능한 모듈들을 제공함으로써 예산절감, 생산성 향상, 품질 보증이 가능함
 - 확장성(Extensibility)
 		다형성(Polymorphism)을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진
 		애플리케이션 개발이 가능함
 - 제어의 역흐름(Inverstion of Control)
 		개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써
 		생산성을 향상시킴
 		
118. 결합도
 - 모듈 간에 상호 의존하는 정도를 나타낸다.
 - 독립적인 모듈이 되기 위해서는 각 모듈 간의 결합도가 약해야 하며 의존하는 모듈이 적어야 한다.
 - 결합도의 종류(약함 < 강함)
 	# 자료결합도 < 스탬프결합도 < 제어결합도 < 외부결합도 < 공통결합도 < 내용결합도
 		# 자료결합도 : 서로 다른 모듈 간에 매개변수 또는 인수를 통해 꼭 필요한 자료만을 교환하는 경우
 		# 스탬프결합도 : 서로 다른 모듈이 동일한 자료 구조를 참조하는 경우의 결합도
 		# 내용결합도 : 한 모듈이 다른 모듈의 내부 자료를 직접적으로 참조하는 경우의 결합도
 		
119. 응집도
 - 모듈 안의 요소들이 서로 관련되어 있는 정도를 나타낸다.
 - 응집도의 종류 (약함 < 강함)
 	# 우연적 < 논리적 < 시간적 < 절차적 < 교환적 < 순차적 < 기능적
 		- 논리적응집도 : 논리적으로 서로 관련 있는 요소들을 모아 하나의 모듈로 작성한 경우의 응집도
 		- 절차적응집도 : 일정한 순서에 의해 처리되어야 할 요소들을 하나의 모듈로 구성한 경우의 응집도로,
 						 전달 데이터와 반환 데이터 사이에 관련이 없음.
 		- 기능적응집도 : 모듈 내부의 모든 기능 요소가 한 가지의 작업만을 수행하는 경우의 응집도
 
120. 재사용
 - 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록
   최적화시키는 작업이다.
 - 재사용 규모에 따른 분류 : 함수와 객체, 컴포넌트, 애플리케이션
 
121. 효과적인 모듈 설계 방안
 - 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
 - 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
 
122. 보안 취약점(Security Vulnerability)
 - 시스템 기능이나 설계, 구현 단계에서의 문제점 등으로 인해 시스템이 가지게 되는 약점을 의미한다.
 
123. 보안 3대 요소
 - 기밀성 : 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용되며,
 			정보가 전송중에 노출되더라도 데이터를 읽을 수 없음
 - 무결성 : 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음
 - 가용성 : 인가받은 사용자는 언제라도 사용할 수 있음
 
124. API(Application Programming Interface)
 - 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스
 - Open API : 누구나 무료로 사용할 수 있게 공개된 API
 
125. 자료 구조의 분류
 - 선형 구조 : 배열, 선형 리스트, 스택, 큐, 데크
 - 비선형 구조 : 트리, 그래프
 
126. 스택(Stack)
 - 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조이다.
 - 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리한다.
 
127. 스택의 응용 분야
 - 함수 호출의 순서 제어
 - 인터럽트의 처리
 - 수식 계산 및 수식 표기법
 - 컴파일러를 이용한 언어 번역
 - 부 프로그램 호출 시 복귀주소 저장
 - 서브루틴 호출 및 복귀주소 저장
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  






